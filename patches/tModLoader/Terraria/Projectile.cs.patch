--- src/Terraria/Terraria/Projectile.cs
+++ src/tModLoader/Terraria/Projectile.cs
@@ -56,7 +_,7 @@
 			public Rectangle GetBulletHitbox(int bulletIndex, Vector2 centerPoint) => Utils.CenteredRectangle(GetBulletPosition(bulletIndex, centerPoint), BulletSize);
 		}
 
-		public static uint[][] perIDStaticNPCImmunity = new uint[950][];
+		public static uint[][] perIDStaticNPCImmunity = new uint[ProjectileID.Count][];
 		public const int SentryLifeTime = 7200;
 		public const int ArrowLifeTime = 1200;
 		public float ownerHitCheckDistance = 1000f;
@@ -179,7 +_,7 @@
 		}
 
 		public static void InitializeStaticThings() {
-			perIDStaticNPCImmunity = new uint[950][];
+			perIDStaticNPCImmunity = new uint[ProjectileID.Count][];
 			for (int i = 0; i < perIDStaticNPCImmunity.Length; i++) {
 				perIDStaticNPCImmunity[i] = new uint[200];
 			}
@@ -188,7 +_,7 @@
 		}
 
 		public static void ResetImmunity() {
-			for (int i = 0; i < 950; i++) {
+			for (int i = 0; i < ProjectileID.Count; i++) {
 				for (int j = 0; j < 200; j++) {
 					perIDStaticNPCImmunity[i][j] = 0u;
 				}
@@ -7823,6 +_,8 @@
 				hostile = true;
 				tileCollide = false;
 			}
+			else if (type >= ProjectileID.VanillaCount)
+				ModdedDefaults(type);
 			else {
 				active = false;
 			}
@@ -7832,6 +_,43 @@
 			maxPenetrate = penetrate;
 		}
 
+		private void ModdedDefaults(int type) {
+			if (type == ProjectileID.KingSlimeShockwave) {
+				hostile = true;
+				width = 288;
+				height = 48;
+				ignoreWater = true;
+				knockBack = 3f;
+				tileCollide = false;
+				timeLeft = 5;
+				penetrate = -1;
+				velocity = new Vector2(0, 0);
+				aiStyle = -1;
+				alpha = 255;
+			}
+			else if (type == ProjectileID.CorruptedFlames) {
+				hostile = true;
+				width = 16;
+				height = 16;
+				tileCollide = false;
+				ignoreWater = true;
+				penetrate = -1;
+				timeLeft = 60 * 8;
+				aiStyle = 185;
+			}
+			else if (type == ProjectileID.SlimeScepterExplosion) {
+				friendly = true;
+				height = 150;
+				width = 150;
+				aiStyle = -1;
+				tileCollide = false;
+				ignoreWater = true;
+				penetrate = -1;
+				timeLeft = 5;
+				alpha = 255;
+			}
+		}
+
 		private void DefaultToWhip() {
 			width = 18;
 			height = 18;
@@ -7937,7 +_,7 @@
 				projectile.ai[1] = projectile.position.Y;
 			}
 
-			if (Type > 0 && Type < 950) {
+			if (Type > 0 && Type < ProjectileID.Count) {
 				if (ProjectileID.Sets.NeedsUUID[Type])
 					projectile.projUUID = projectile.identity;
 
@@ -8987,13 +_,13 @@
 									}
 
 									int num9 = (int)((float)damage * num5);
-									if (type > 0 && type < 950 && ProjectileID.Sets.StardustDragon[type]) {
+									if (type > 0 && type < ProjectileID.Count && ProjectileID.Sets.StardustDragon[type]) {
 										float value2 = (scale - 1f) * 100f;
 										value2 = Utils.Clamp(value2, 0f, 50f);
 										num9 = (int)((float)num9 * (1f + value2 * 0.23f));
 									}
 
-									if (type > 0 && type < 950 && ProjectileID.Sets.StormTiger[type]) {
+									if (type > 0 && type < ProjectileID.Count && ProjectileID.Sets.StormTiger[type]) {
 										int num10 = Math.Max(0, Main.player[owner].ownedProjectileCounts[831] - 1);
 										num9 = (int)((float)num9 * (1f + (float)num10 * 0.33333334f));
 									}
@@ -9295,7 +_,7 @@
 											num18 = (int)((double)num18 * 0.75);
 									}
 
-									if (Main.netMode != 2 && nPC.type == 439 && type >= 0 && type <= 950 && ProjectileID.Sets.CountsAsHoming[type])
+									if (Main.netMode != 2 && nPC.type == 439 && type >= 0 && type <= ProjectileID.Count && ProjectileID.Sets.CountsAsHoming[type])
 										num18 = (int)((float)num18 * 0.75f);
 
 									if (type == 497 && penetrate != 1) {
@@ -25388,6 +_,19 @@
 			else if (aiStyle == 184) {
 				AI_184_BadTorchLuck();
 			}
+			else if (aiStyle == 185)
+				AI_185_CorruptedFlames();
+		}
+
+		private void AI_185_CorruptedFlames() {
+			if (localAI[0] == 0f) {
+				SoundEngine.PlaySound(SoundID.Item20, Center);
+				localAI[0] = 1f;
+			}
+			Dust dust;
+			dust = Main.dust[Terraria.Dust.NewDust(base.position, width, height, 27, 0f, 0f, 0, new Color(255, 255, 255), 3f)];
+			dust.noGravity = true;
+			Lighting.AddLight(base.Center, new Vector3(0.5f, 0f, 1f)); //Dark Purple Light
 		}
 
 		private void AI_184_BadTorchLuck() {
@@ -25703,22 +_,85 @@
 			}
 
 			if (num2 < 1f) {
+				switch (Main.player[Main.myPlayer].name) { //brackets are only there so I can reuse the same local variable names
+					case "Stevie": {
+							FinalFractalHelper.FinalFractalProfile finalFractalProfileFunny = FinalFractalHelper.GetFinalFractalProfileFunny((int)ai[1]);
+							Vector2 value4 = (rotation - (float)Math.PI / 2f).ToRotationVector2();
+							Vector2 center = base.Center;
+							int num11 = 1 + (int)(velocity.Length() / 100f);
+							num11 = (int)((float)num11 * Utils.GetLerpValue(0f, 0.5f, lerpValue2, clamped: true) * Utils.GetLerpValue(1f, 0.5f, lerpValue2, clamped: true));
+							if (num11 < 1)
+								num11 = 1;
+
+							for (int i = 0; i < num11; i++) {
+								finalFractalProfileFunny.dustMethod(center + value4 * finalFractalProfileFunny.trailWidth * MathHelper.Lerp(0.5f, 1f, Main.rand.NextFloat()), rotation - (float)Math.PI / 2f + (float)Math.PI / 2f * (float)spriteDirection, player.velocity);
+							}
+
+							Vector3 vector = finalFractalProfileFunny.trailColor.ToVector3();
+							Vector3 value5 = Vector3.Lerp(Vector3.One, vector, 0.7f);
+							Lighting.AddLight(base.Center, vector * 0.5f * Opacity);
+							Lighting.AddLight(mountedCenter, value5 * Opacity * 0.15f);
+						}
+						break;
+					case "Scalie":
+					case "Terra": {
+							FinalFractalHelper.FinalFractalProfile finalFractalProfileTerra = FinalFractalHelper.GetFinalFractalProfileTerra((int)ai[1]);
+							Vector2 value4 = (rotation - (float)Math.PI / 2f).ToRotationVector2();
+							Vector2 center = base.Center;
+							int num11 = 1 + (int)(velocity.Length() / 100f);
+							num11 = (int)((float)num11 * Utils.GetLerpValue(0f, 0.5f, lerpValue2, clamped: true) * Utils.GetLerpValue(1f, 0.5f, lerpValue2, clamped: true));
+							if (num11 < 1)
+								num11 = 1;
+
+							for (int i = 0; i < num11; i++) {
+								finalFractalProfileTerra.dustMethod(center + value4 * finalFractalProfileTerra.trailWidth * MathHelper.Lerp(0.5f, 1f, Main.rand.NextFloat()), rotation - (float)Math.PI / 2f + (float)Math.PI / 2f * (float)spriteDirection, player.velocity);
+							}
+
+							Vector3 vector = finalFractalProfileTerra.trailColor.ToVector3();
+							Vector3 value5 = Vector3.Lerp(Vector3.One, vector, 0.7f);
+							Lighting.AddLight(base.Center, vector * 0.5f * Opacity);
+							Lighting.AddLight(mountedCenter, value5 * Opacity * 0.15f);
+						}
+						break;
+					case "pbone": {
+							FinalFractalHelper.FinalFractalProfile finalFractalProfileCactus = FinalFractalHelper.GetFinalFractalProfileCactus((int)ai[1]);
+							Vector2 value4 = (rotation - (float)Math.PI / 2f).ToRotationVector2();
+							Vector2 center = base.Center;
+							int num11 = 1 + (int)(velocity.Length() / 100f);
+							num11 = (int)((float)num11 * Utils.GetLerpValue(0f, 0.5f, lerpValue2, clamped: true) * Utils.GetLerpValue(1f, 0.5f, lerpValue2, clamped: true));
+							if (num11 < 1)
+								num11 = 1;
+
+							for (int i = 0; i < num11; i++) {
+								finalFractalProfileCactus.dustMethod(center + value4 * finalFractalProfileCactus.trailWidth * MathHelper.Lerp(0.5f, 1f, Main.rand.NextFloat()), rotation - (float)Math.PI / 2f + (float)Math.PI / 2f * (float)spriteDirection, player.velocity);
+							}
+
+							Vector3 vector = finalFractalProfileCactus.trailColor.ToVector3();
+							Vector3 value5 = Vector3.Lerp(Vector3.One, vector, 0.7f);
+							Lighting.AddLight(base.Center, vector * 0.5f * Opacity);
+							Lighting.AddLight(mountedCenter, value5 * Opacity * 0.15f);
+						}
+						break;
+					default: {
-				FinalFractalHelper.FinalFractalProfile finalFractalProfile = FinalFractalHelper.GetFinalFractalProfile((int)ai[1]);
+							FinalFractalHelper.FinalFractalProfile finalFractalProfile = FinalFractalHelper.GetFinalFractalProfile((int)ai[1]);
-				Vector2 value4 = (rotation - (float)Math.PI / 2f).ToRotationVector2();
+							Vector2 value4 = (rotation - (float)Math.PI / 2f).ToRotationVector2();
-				Vector2 center = base.Center;
+							Vector2 center = base.Center;
-				int num11 = 1 + (int)(velocity.Length() / 100f);
+							int num11 = 1 + (int)(velocity.Length() / 100f);
-				num11 = (int)((float)num11 * Utils.GetLerpValue(0f, 0.5f, lerpValue2, clamped: true) * Utils.GetLerpValue(1f, 0.5f, lerpValue2, clamped: true));
+							num11 = (int)((float)num11 * Utils.GetLerpValue(0f, 0.5f, lerpValue2, clamped: true) * Utils.GetLerpValue(1f, 0.5f, lerpValue2, clamped: true));
-				if (num11 < 1)
+							if (num11 < 1)
-					num11 = 1;
+								num11 = 1;
 
-				for (int i = 0; i < num11; i++) {
+							for (int i = 0; i < num11; i++) {
-					finalFractalProfile.dustMethod(center + value4 * finalFractalProfile.trailWidth * MathHelper.Lerp(0.5f, 1f, Main.rand.NextFloat()), rotation - (float)Math.PI / 2f + (float)Math.PI / 2f * (float)spriteDirection, player.velocity);
+								finalFractalProfile.dustMethod(center + value4 * finalFractalProfile.trailWidth * MathHelper.Lerp(0.5f, 1f, Main.rand.NextFloat()), rotation - (float)Math.PI / 2f + (float)Math.PI / 2f * (float)spriteDirection, player.velocity);
+							}
+
+							Vector3 vector = finalFractalProfile.trailColor.ToVector3();
+							Vector3 value5 = Vector3.Lerp(Vector3.One, vector, 0.7f);
+							Lighting.AddLight(base.Center, vector * 0.5f * Opacity);
+							Lighting.AddLight(mountedCenter, value5 * Opacity * 0.15f);
+						}
+						break;
 				}
-
-				Vector3 vector = finalFractalProfile.trailColor.ToVector3();
-				Vector3 value5 = Vector3.Lerp(Vector3.One, vector, 0.7f);
-				Lighting.AddLight(base.Center, vector * 0.5f * Opacity);
-				Lighting.AddLight(mountedCenter, value5 * Opacity * 0.15f);
 			}
 
 			Opacity = Utils.GetLerpValue(0f, 5f, localAI[0], clamped: true) * Utils.GetLerpValue(120f, 115f, localAI[0], clamped: true);
